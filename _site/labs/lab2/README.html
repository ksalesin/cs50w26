<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>CS 50 | Lab</title>
    <link rel="stylesheet" href="/~ksalesin/cs50/styles.css">
    <link rel="stylesheet" href="/~ksalesin/cs50/github-markdown.css">
</head>
<body>
    <div class="markdown-body nav">
        <h3><a href="/~ksalesin/cs50/" id="cs50">CS 50: Software Design and Implementation (Winter 2026)</a></h3>
        <ul>
            <li><a href="/~ksalesin/cs50/syllabus.html">Syllabus</a></li>
            <li><a href="/~ksalesin/cs50/schedule.html">Schedule</a></li>
            <li><a href="/~ksalesin/cs50/style.html">Style Guide</a></li>
            <li><a href="/~ksalesin/cs50/resources.html">Resources</a></li>
            <!-- <li><a href="/submit.html">Submit</a></li> -->
            <li id="knowledge-base"><a href="http://spongium.org/" target="_blank">Knowledge Base</a></li>
        </ul>
    </div>
    <div class="markdown-body content">
        <h1>Lab 2: C programming</h1>
<p>Design, write, document, and test the following C programs.
In each case you will need to write a testing script.</p>
<p><em><strong>Point breakdown:</strong></em></p>
<ul>
<li>(30 points) <code>chill.c</code></li>
<li>(30 points) <code>words.c</code></li>
<li>(40 points) <code>histo.c</code></li>
</ul>
<h2>Reminder</h2>
<p>Grading will focus on <a href="/~ksalesin/cs50/style.html">CS 50 coding style</a>—including consistent formatting, selection of identifier names, and use of meaningful comments—in addition to correctness and testing.</p>
<p><strong>Your C code must compile without producing any compiler warnings.</strong>
You will lose points if the compiler produces warnings when using our CS50-standard compiler flags (i.e. when compiled with <code>mygcc</code>).</p>
<h2>Preparation</h2>
<!-- @CHANGEME update the invitation link -->
<h3>1.1 Accept the GitHub Classroom assignment</h3>
<ul>
<li>Click the invitation link in the Canvas assignment for Lab 2.</li>
<li>Accept the assignment in GitHub.
<ul>
<li>You may see an &quot;error&quot; message along the lines of &quot;Repository Access Issue - You no longer have access to your assignment repository. Contact your teacher for support.&quot; Ignore this.</li>
</ul>
</li>
<li>Check your email – there should be an email from GitHub asking you to accept the invitation to the new repository (check your Junk if you don't see it). Accept the invite.</li>
<li>This should take you to a new private repository with the name <code>lab2-&lt;username&gt;</code>. This is the repo you will use for Lab 2.
<ul>
<li>The url for this repository will be <code>https://github.com/DartmouthCS50W26/lab2-&lt;username&gt;</code> (you may want to bookmark it). It likely will not show up in your personal repositories (if you click on your profile pic and then Repositories) since the DartmouthCS50W26 organization is the owner.</li>
</ul>
</li>
</ul>
<h3>1.2 Initialize your GitHub repo</h3>
<ul>
<li>Clone this repo to a <code>lab2</code> folder on plink. What command did you run for that?</li>
<li>Create a <code>README.md</code> file in <code>lab2</code> with the header <code># Lab 2</code>. Indicate your name in the first line after the header. You can use this file to provide any overall comments you want to convey to the grader.</li>
<li>Create a <code>.gitignore</code> file in <code>lab2</code> – this is a list of files that git will automatically ignore. As you work on the tasks below, add the paths of any executable/binary files that are generated to your <code>.gitignore</code> (it is generally considered bad git practice to commit binary files).</li>
</ul>
<div class="markdown-alert markdown-alert-tip"><p class="markdown-alert-title"><svg class="octicon octicon-light-bulb mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z"></path></svg>Tip</p><p>This is not an issue on Linux, but if you are ever working with git on a Mac, you will want to add <code>.DS_Store</code> to your <code>.gitignore</code>, which is a hidden file that Macs automatically generate for every folder.</p>
</div>
<ul>
<li>Make sure that <code>README.md</code> and <code>.gitignore</code> are tracked for changes. What command did you use for that?</li>
<li>Write the answers to the git questions above in your <code>README</code>, under a subheading <code>## Answers to question 1</code>.</li>
</ul>
<div class="markdown-alert markdown-alert-tip"><p class="markdown-alert-title"><svg class="octicon octicon-light-bulb mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z"></path></svg>Tip</p><p>Remember that you can preview Markdown files with various Markdown-editing or -rendering tools (see: <a href="https://github.com/CS50DartmouthFA2025/home/blob/main/logistics/systems.md#markdown">Markdown resources</a>) but we will read it on GitHub, so before you make your final submission decision be sure to check it there.</p>
</div>
<h3>1.3 Programming questions</h3>
<p>Within <code>lab2</code>, make three directories where you'll do your work:</p>
<pre><code>mkdir chill words histo
</code></pre>
<p>In each subdirectory, write the corresponding program as described below.
Remember to add any binary files (e.g. <code>chill/chill</code>, <code>words/words</code>, <code>histo/histo</code>) and anything else you don't want committed to your <code>.gitignore</code>.</p>
<!-- Some other things that are good defaults to have for a `gitignore`:
```
# Emacs backup and scratch files
*~
\#*\#
.\#*

# MacOS stuff
.DS_Store
.AppleDouble
.LSOverride
Icon?
._*
``` -->
<hr>
<h1>What to submit</h1>
<p>When finished, your <code>lab2</code> directory should contain a <code>README.md</code> file and three subdirectories, each of which contains certain files as detailed below.</p>
<p>You should add <strong>only</strong> the necessary files to your repo
<em>(do not commit any compiled C programs!)</em>.
Check <code>git status</code> before you commit: it will list the files that will be committed near the top and the files that will not be committed, or are 'untracked', near the bottom.
<em>Study the status output carefully: if you miss adding a file we need, you'll lose points, and if you add a scratch or binary file that should not be in the repo, you'll lose points.</em></p>
<div class="markdown-alert markdown-alert-important"><p class="markdown-alert-title"><svg class="octicon octicon-report mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Important</p><p><strong>Your final push to your private <code>lab2</code> repo before the assignment deadline (Fri Jan 23rd at 11:59 pm) will serve as your submission for Lab 2.</strong> Do not push any changes after the deadline (unless you are using one of your extensions). You do not need to submit anything to Canvas. The TAs have access to your repos through GitHub Classroom and will clone each of your repos to plink for grading and testing.</p>
</div>
<hr>
<h2>chill.c</h2>
<p>Write a C program to calculate &quot;wind chill&quot; based on the current temperature and wind speed.
The standard formula for this calculation is:</p>
<pre><code class="language-Matlab">    Wind Chill = 35.74 + 0.6215T - 35.75(V^0.16) + 0.4275T(V^0.16)
</code></pre>
<p>where <code>T</code> is the temperature in degrees Fahrenheit (when less than 50 and greater than -99) and <code>V</code> is the wind velocity in miles per hour.
The <code>^</code> character denotes exponentiation.
Note that the above formula is <em>not</em> written in C programming language syntax.</p>
<h3>Input:</h3>
<p>The user may run your program with no arguments, one argument, or two arguments as explained below.
<code>chill</code> does not read from stdin or files.</p>
<h3>Output (no arguments):</h3>
<p>If the user provides no arguments to your program, it should print out a table of temperatures (from -10 to +40 by 10's) and and wind speeds (from 5 to 15 by 5's).
Your output should look similar to the following, with nice columns and titles:</p>
<pre><code class="language-bash">$ ./chill
  Temp   Wind  Chill
 -----  -----  -----
 -10.0    5.0  -22.3
 -10.0   10.0  -28.3
 -10.0   15.0  -32.2

   0.0    5.0  -10.5
   0.0   10.0  -15.9
   0.0   15.0  -19.4

  10.0    5.0    1.2
  10.0   10.0   -3.5
  10.0   15.0   -6.6

  20.0    5.0   13.0
  20.0   10.0    8.9
  20.0   15.0    6.2

  30.0    5.0   24.7
  30.0   10.0   21.2
  30.0   15.0   19.0

  40.0    5.0   36.5
  40.0   10.0   33.6
  40.0   15.0   31.8
</code></pre>
<p>Notice that we print everything in the format &quot;x.y&quot;, with exactly one decimal place.</p>
<blockquote>
<p>This format is most important when the user specifies temperature or windspeed, because the user may specify a non-integral value and it may be misleading to print it as an integer.</p>
</blockquote>
<h3>Output (one argument):</h3>
<p>If the user provides one argument, it refers to a temperature (expressed as a floating-point number).
You may assume (without checking) the argument is a valid floating-point number.
If that temperature is less than 50 and greater than -99, it is acceptable; <code>chill</code> then prints a table of wind speeds (from 5 to 15 by 5's) and the calculated wind chills <em>for that temperature only</em>.
Your program's output for one argument should look like this:</p>
<pre><code class="language-bash">$ ./chill 32
  Temp   Wind  Chill
 -----  -----  -----
  32.0    5.0   27.1
  32.0   10.0   23.7
  32.0   15.0   21.6
</code></pre>
<h3>Output (two arguments):</h3>
<p>If the user provides two arguments, they refer to be temperature and velocity, respectively (expressed as floating-point numbers).
You may assume (without checking) the arguments are valid floating-point numbers.
The temperature must be less than 50 and greater than -99.
The velocity must be greater than or equal to 0.5.</p>
<p>If the arguments are acceptable, then your program should calculate and print the wind chill for <em>that temperature and velocity only</em>.</p>
<p>Your program's output for two arguments should look like this:</p>
<pre><code class="language-bash">$ ./chill 32.5 10
  Temp   Wind  Chill
 -----  -----  -----
  32.5   10.0   24.3
</code></pre>
<p>If either argument is out of range, your program should issue a message and exit.
Here's an example:</p>
<pre><code class="language-bash">$ ./chill 55
./chill: Temperature must be less than or equal to 50.0 degrees Fahrenheit
$ ./chill 10 0
./chill: Wind velocity must be greater than or equal to 0.5 MPH
</code></pre>
<h3>Output (more than two arguments):</h3>
<p>Print a &quot;usage&quot; line and exit with error status.</p>
<h3>Exit:</h3>
<p>If the program terminates normally, it exits with a return code  of <code>0</code>.
Otherwise, it terminates with a non-zero return code.</p>
<h3>Compiling:</h3>
<p>You will likely need the math library.
To use it, add <code>#include &lt;math.h&gt;</code> to your <code>chill.c</code> file, and add <code>-lm</code> to your <code>mygcc</code> command.
(<code>-lm</code> is short for &quot;library math&quot;).</p>
<pre><code class="language-bash">mygcc chill.c -lm -o chill
</code></pre>
<h3>Testing:</h3>
<p>Write a simple bash script <code>testing.sh</code> that will execute a sequence of commands that demonstrate (a) that your solution works and (b) that you have thoughfully designed test cases that address both normal and erroneous cases.
If you then run it like this:</p>
<pre><code class="language-bash">$ bash -v testing.sh &gt;&amp; testing.out
</code></pre>
<blockquote>
<p>The <code>&gt;&amp;</code> notation means to send both stdout and stderr to the following filename; it is shorthand for <code>&gt; testing.out 2&gt;&amp;1</code> and much more readable!</p>
</blockquote>
<p>Here bash (with <code>-v</code>) will print each command as it runs, and save the stdout and stderr as well... so we can see what your test does.
For example, the following <code>testing.sh</code> contents contain the above example tests.
I include comments to help the reader know the purpose of each test.</p>
<pre><code># zero arguments                                                                    
./chill
# one argument                                                                      
./chill 32
# two arguments                                                                     
./chill 32.5 10
# temp out of range                                                                 
./chill 55
# wind out of range                                                                 
./chill 10 0
</code></pre>
<p>Your testing should go beyond this example.</p>
<h3>What to submit:</h3>
<p>We recommend that you commit the <code>chill</code> directory when you have it working, because it is logically separate from commits you may later (or earlier) have done on the other parts of this assignment.
Use a meaningful commit message.</p>
<p>Your directory should contain exactly these files:</p>
<pre><code>chill
├── chill.c
├── testing.out
└── testing.sh
</code></pre>
<!-- Note the `.gitignore` file, which causes git to ignore the binary file `chill` (binary files should not be committed!). -->
<hr>
<h2>words.c</h2>
<p>Write a C program called <code>words</code> that breaks its input into a series of words, one per line.
It may take input from stdin, or from files whose names are listed as arguments.</p>
<h3>Usage:</h3>
<pre><code>words [filename]...
</code></pre>
<h3>Input:</h3>
<p>When no filenames are given on the command line, <code>words</code> reads from stdin.</p>
<p>When one or more filenames are given on the command line, <code>words</code> reads from each file in sequence.</p>
<p>If the special filename <code>-</code> is given as one of the filenames, the stdin is read at that point in the sequence.</p>
<h3>Output:</h3>
<p>In any case, the stdout should consist of a sequence of lines, with exactly one word on each output line (i.e. each output line contains exactly one word and no other characters).
<strong>A <em>word</em> is a maximal sequence of one or more letters, bounded by the beginning of file, end of file, or any non-letter character.</strong></p>
<p>Any error messages are written to stderr.
In this program, the most likely error would be failure to open a file named as a command-line argument.</p>
<h3>Exit:</h3>
<p>If the program terminates normally, it exits with a return code  of <code>0</code>.
Otherwise, it terminates with a non-zero return code.</p>
<h3>Hints:</h3>
<ul>
<li>Although you may be tempted to think of the input as a sequence of lines, it may be helpful to think of it as a sequence of characters.</li>
<li>Note it is possible for the output to be empty, if there are no words in any of the input files.</li>
<li>Check out the <a href="#ctype">ctype</a> functions, below.</li>
<li>Consider a function that processes a file, given a <code>FILE *</code> as parameter.</li>
<li>Remember that <code>stdin</code> is just a <code>FILE *</code> and can be used anywhere a <code>FILE *</code> might be used for reading.</li>
<li>Remember that stdin is not always attached to the keyboard - the input of <code>words</code> may be from a pipe or a file (e.g., <code>./words &lt; thesis.txt</code>).</li>
</ul>
<h3>Testing:</h3>
<p>Write a simple bash script <code>testing.sh</code> that will execute a sequence of commands that demonstrate (a) that your solution works and (b) that you have thoughfully designed test cases that address both normal and erroneous cases.
If you then run it like this:</p>
<pre><code class="language-bash">$ bash -v testing.sh &gt;&amp; testing.out
</code></pre>
<p>Here bash (with <code>-v</code>) will print each command as it runs, and save the stdout and stderr as well... so we can see what your test does.</p>
<h3>What to submit:</h3>
<p>We recommend that you commit the <code>words</code> directory when you have it working, because it is logically separate from commits you may later (or earlier) have done on the other parts of this assignment.
Use a meaningful commit message.</p>
<p>Your directory should contain these files:</p>
<pre><code>words
├── testing.out
├── testing.sh
└── words.c
</code></pre>
<p>plus any input files you need for your testing script.</p>
<!-- Note the `.gitignore` file, which causes git to ignore the binary file `words ` (binary files should not be committed!). -->
<h2>histo.c</h2>
<p>Write a program that reads a series of positive integers from stdin, and prints out a histogram.
There should be 16 bins in your histogram.
The catch? You don't know in advance the <em>range</em> of input values; assume the integers range from 0 to some unknown positive maximum.
Thus, you will need to dynamically scale the bin size for your histogram.
An example is below.</p>
<h3>Usage:</h3>
<p>There are no command-line arguments.</p>
<h3>Requirements:</h3>
<p>You must begin with bin size 1, and double it as needed so all positive integers observed on input fit within the histogram.</p>
<p>You must have 16 bins.
The number '16' should appear only <em>once</em> in your code.</p>
<h3>Input:</h3>
<p>Input is read from stdin, whether from the keyboard, redirected from a file, or piped in from another command.
Assume the input contains only integers, separated by white space (space, tab, newline).
Assume the smallest integer is zero; ignore any negative integers.
(These assumptions make it easy to use <code>scanf</code> for your input.)</p>
<p>As always, any other assumptions you make should be documented in a <code>README.md</code> file in this directory.</p>
<h3>Output:</h3>
<p>See examples below.</p>
<h3>Exit:</h3>
<p>This program has no arguments and does not check its input for errors, so it should always exit with zero status.</p>
<h3>Examples:</h3>
<p>Here we compile and run the program, and type a set of numbers (spread over three lines, but it doesn't matter as long as I put space or newline between numbers), ending with <code>ctrl-D</code> on the beginning of a line.
(That sends EOF to the program.)  It then printed a histogram, nicely labeling each line with the range of values assigned to that bin, and printing the count of values that fell into that bin.</p>
<pre><code>$ mygcc histo.c -o histo
$ ./histo
16 bins of size 1 for range [0,16)
3 -4 5 1 7 0
8 0 15 12 3 5
3 3 3 3 3
^D
[ 0: 0] **
[ 1: 1] *
[ 2: 2]
[ 3: 3] *******
[ 4: 4]
[ 5: 5] **
[ 6: 6]
[ 7: 7] *
[ 8: 8] *
[ 9: 9]
[10:10]
[11:11]
[12:12] *
[13:13]
[14:14]
[15:15] *
$
</code></pre>
<p>Now watch what happens if I input a number outside the original range of [0,16).</p>
<pre><code>$ ./histo
16 bins of size 1 for range [0,16)
3 -4 5 1 7 0
8 0 15 12 3 5
18
16 bins of size 2 for range [0,32)
19 20 30 7 12
50
16 bins of size 4 for range [0,64)
34
32
19
44
^D
[ 0: 3] *****
[ 4: 7] ****
[ 8:11] *
[12:15] ***
[16:19] ***
[20:23] *
[24:27]
[28:31] *
[32:35] **
[36:39]
[40:43]
[44:47] *
[48:51] *
[52:55]
[56:59]
[60:63]
$
</code></pre>
<p>Each time it sees a number outside the current range, it doubles the range and doubles the size of each bin.
(Notice also the [low:high] labels in the histogram; this notation includes both <em>low</em> and <em>high</em> and everything in between.) It might have to repeat the doubling if I put in a number well past the current bin size:</p>
<pre><code>$ ./histo
16 bins of size 1 for range [0,16)
150
16 bins of size 2 for range [0,32)
16 bins of size 4 for range [0,64)
16 bins of size 8 for range [0,128)
16 bins of size 16 for range [0,256)
^D
[  0: 15]
[ 16: 31]
[ 32: 47]
[ 48: 63]
[ 64: 79]
[ 80: 95]
[ 96:111]
[112:127]
[128:143]
[144:159] *
[160:175]
[176:191]
[192:207]
[208:223]
[224:239]
[240:255]
$
</code></pre>
<p>Here's an example using bash syntax to generate a list of numbers, and piping the output to <code>histo</code>:</p>
<pre><code>$ echo {1..16} 150 | ./histo
16 bins of size 1 for range [0,16)
16 bins of size 2 for range [0,32)
16 bins of size 4 for range [0,64)
16 bins of size 8 for range [0,128)
16 bins of size 16 for range [0,256)
[  0: 15] ***************
[ 16: 31] *
[ 32: 47]
[ 48: 63]
[ 64: 79]
[ 80: 95]
[ 96:111]
[112:127]
[128:143]
[144:159] *
[160:175]
[176:191]
[192:207]
[208:223]
[224:239]
[240:255]
$
</code></pre>
<p>Although we scale the bin size, I'm not asking you to scale the bin count, which is fixed to be 16, or to worry about a bin with a huge count - it's ok if the stars march off the screen.</p>
<p>I took some pains to format the [low:high] range indicators for each row, using a fixed-width field just wide enough to hold the biggest number.
It's a nice touch (read <code>man printf</code> for some clues) but it's ok if you make a simpler assumption (e.g., always use 6-digit field width).</p>
<h3>Representing a histogram:</h3>
<p>You will need an array of 16 bins to represent the number of integers observed in each bin.
You'll need to keep track of the bin size and the range of the histogram.
If you observe a value outside the range, you should double the bin size and range - but first you need to compress the current 16 bins into the first 8 bins.
You'll likely need one loop to compute the new values for the lower half of the bins (each bin receiving the sum of two bins' counts), and then another to assign the new value (0) to the upper half of the bins.</p>
<p>(Again: the number '16' may only occur <em>once</em> in your code; scattering hard-coded numbers around your code is bad style.)</p>
<p>Notice that the number of bins, bin size, and histogram range are all powers of 2.</p>
<h3>Testing:</h3>
<p>Write a simple bash script <code>testing.sh</code> that will execute a sequence of commands that demonstrate (a) that your solution works and (b) that you have thoughfully designed test cases that address both normal and erroneous cases.
If you then run it like this:</p>
<pre><code class="language-bash">$ bash -v testing.sh &gt;&amp; testing.out
</code></pre>
<p>Here bash (with <code>-v</code>) will print each command as it runs, and save the stdout and stderr as well... so we can see what your test does.</p>
<p>Unlike some of my examples above, <em>it must not expect keyboard input.</em>
The stdin should come from input files or pipes.</p>
<h3>What to submit:</h3>
<p>We recommend that you commit the <code>histo</code> directory when you have it working, because it is logically separate from commits you may later (or earlier) have done on the other parts of this assignment.
Use a meaningful commit message.</p>
<p>Your directory should contain these files:</p>
<pre><code>histo
├── histo.c
├── testing.out
└── testing.sh
</code></pre>
<p>plus any input files you need for your testing script.</p>
<hr>
<h2>ctype</h2>
<p>The <code>ctype.h</code> header file defines several useful functions, listed below.
For information about any of these, check its man page; e.g., <code>man isdigit</code>.</p>
<pre><code class="language-c">   int   isalnum(int);
   int   isalpha(int);
   int   isascii(int);
   int   isblank(int);
   int   iscntrl(int);
   int   isdigit(int);
   int   isgraph(int);
   int   islower(int);
   int   isprint(int);
   int   ispunct(int);
   int   isspace(int);
   int   isupper(int);
   int   isxdigit(int);
   int   toascii(int);
   int   tolower(int);
   int   toupper(int);
</code></pre>

    </div>
</body>
</html>