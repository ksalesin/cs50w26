<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title></title>
    <link rel="stylesheet" href="/~ksalesin/cs50/styles.css">
    <link rel="stylesheet" href="/~ksalesin/cs50/github-markdown.css">
</head>
<body>
    <div class="markdown-body nav">
        <h3><a href="/~ksalesin/cs50/" id="cs50">CS 50: Software Design and Implementation</a></h3>
        <ul>
            <li><a href="/~ksalesin/cs50/syllabus">Syllabus</a></li>
            <li><a href="/~ksalesin/cs50/schedule">Schedule</a></li>
            <li><a href="/~ksalesin/cs50/style">Style Guide</a></li>
            <li><a href="/~ksalesin/cs50/resources">Resources</a></li>
            <!-- <li><a href="/submit.html">Submit</a></li> -->
            <li id="knowledge-base"><a href="http://plink.cs.dartmouth.edu:3000/" target="_blank">Knowledge Base</a></li>
        </ul>
    </div>
    <div class="markdown-body content">
        <p>In this lab you'll continue the Tiny Search Engine (TSE) by coding the Querier according to the <a href="REQUIREMENTS.md">Requirements Spec</a>.</p>
<p>You will also write the Design Spec and Implementation Spec.</p>
<p>Grading will focus on <a href="https://github.com/CS50DartmouthFA2025/home/blob/main/logistics/style.md">CS50 coding style</a> - including consistent formatting, selection of identifier names, and use of meaningful comments - in addition to correctness, testing, and documentation.</p>
<p><em><strong>Your C code must compile without producing any compiler warnings.</strong></em>  You will lose points if the compiler produces warnings when using our CS50-standard compiler flags.</p>
<p><em><strong>If your submitted code fails to compile, or triggers a segmentation fault,</strong></em> you will fail some or all of our correctness tests.
Write defensive code: each function should check its pointer parameters for NULL, and take some appropriate (safe) action.
Write solid unit tests, test drivers, and use regression testing as your development proceeds.</p>
<p>If your submitted version has <em>known bugs</em>, that is, cases where it fails your own test cases, <em>and you describe those cases in your README file</em>, we will halve the number of points you lose for those cases.
In short, it is far better for you to demonstrate you <em>know</em> about the bug than to submit and hope we won't find it.</p>
<p><em><strong>Valgrind should report no memory errors or memory leaks, when crawler exits normally.</strong></em>
You will lose points for memory errors and leaks reported by valgrind on our tests.</p>
<h2>Preparation</h2>
<ol>
<li>Start with the same repository you used for Lab 5.
<em>Before you begin</em>, make sure you submitted Lab 5 correctly, <a href="https://github.com/CS50DartmouthFA2025/home/blob/main/labs/submit.md">as instructed</a>.</li>
<li>Check to ensure your local repo is clean with <code>make clean</code> and everything looks correct according to <code>git status</code>.
<strong>Do not proceed</strong> if you have uncommitted changes or unpushed commits.
Seek help if you need to sort out your repo or GitHub.</li>
<li>Ensure you are again working on the <code>main</code> branch <strong>and</strong> that the <code>main</code> branch is up to date if you made any changes on <code>submit5</code> after branching off <code>main</code>.</li>
<li>Create a new subdirectory <code>querier</code>.</li>
</ol>
<h2>Assignment</h2>
<p>:point_right:
Write the third sub-system of the Tiny Search Engine, the <em>querier</em>.
Your design and implementation must follow the <strong>Querier Requirements Spec</strong> (aka &quot;the Specs&quot;), and make good use of our abstract data structures.</p>
<p><strong>In the top directory,</strong></p>
<ol>
<li>Uncomment the commands for querier, so <code>make</code> and <code>make clean</code> work to build (or clean) the libraries, crawler, indexer, and querier.</li>
</ol>
<p><strong>In the <code>querier</code> subdirectory,</strong></p>
<ol>
<li>Add a file <code>DESIGN.md</code> to provide the Design Spec for querier.
Your <code>DESIGN.md</code> file should not repeat the information provided in the assignment or in the <a href="REQUIREMENTS.md">Requirements Spec</a>; instead, it should describe the abstract data structures and pseudo code for <em>your</em> querier.</li>
<li>Add a file <code>IMPLEMENTATION.md</code> to provide the implementation spec and testing plan for querier.
Your <code>IMPLEMENTATION.md</code> file need not repeat the information provided in the assignment or other specs; instead, it should describe implementation details specific to <em>your</em> implementation.</li>
<li>Add a file <code>README.md</code> to describe any assumptions you made while writing the querier, any ways in which your implementation differs from the Specs, or any ways in which you know your implementation fails to work.</li>
<li>Extend the <code>README.md</code> file to clearly <strong>indicate how much of the functionality you implemented</strong>, as <a href="#grading">described below</a>.</li>
<li>Write a program <code>querier.c</code> according to the Specs.
Your program should make good use of code from <code>common.a</code> and <code>libcs50.a</code>, created in earlier labs.</li>
<li>Write a <code>Makefile</code> that will, by default, build the <code>querier</code> executable program.</li>
<li>Add a <code>make clean</code> target that removes files produced by Make or your tests.</li>
<li>Add a <code>make test</code> target that tests your querier.</li>
<li>Write a <code>testing.sh</code> bash script that can be run by <code>make test</code>.
This script must include good comments describing your tests.
For best results, <code>make test</code> should run <code>bash -v testing.sh</code>.</li>
<li>Save the output of your tests with <code>make test &amp;&gt; testing.out</code>.</li>
<li>Add a <code>.gitignore</code> file telling Git to ignore the binary files (like <code>querier</code>) and other unnecessary files in this directory.</li>
</ol>
<h3>Submission</h3>
<p>Add/commit all the code and ancillary files required to build and test your solution; at a minimum your <strong>querier</strong> directory should include the following files:
<code>.gitignore README.md DESIGN.md IMPLEMENTATION.md Makefile querier.c testing.sh testing.out</code>
and your <strong>common</strong> directory should contain the following files:
<code>Makefile index.h index.c pagedir.h pagedir.c word.h word.c</code></p>
<p><em>Do not commit any data files produced by the crawler or indexer, any binary/object files produced by the compiler, backup files, core dumps, etc.</em></p>
<p>The graders must be able to build your TSE <em>from the top-level directory</em> without compilation errors and test your querier without run-time errors.</p>
<p>See the <a href="https://github.com/CS50DartmouthFA2025/home/blob/main/logistics/submit.md">Lab submission instructions</a>.</p>
<h2>Grading</h2>
<p>Lab 6 is scored on the basis of 100 points, with Delivery, Documentation, Style, Testing comprising most of the points.</p>
<p>&quot;Functionality&quot; represents 30/100 points.
In recognition that you might find it best to start simple and slowly enhance your solution as you get the simpler version working, you can earn points on a sliding scale as follows:</p>
<ul>
<li>10 points if your querier prints the set of documents that contain all the words in the query; you may treat operators ('and', 'or') as regular words.</li>
<li>20 points if your querier also supports 'and' and 'or' operators, but without precedence (in mathematical terms, it treats them as <em>left associative, equal precedence</em> operators).</li>
<li>25 points if your querier also supports 'and' precedence over 'or'.</li>
<li>30 points if your querier also prints the document set in decreasing order by score, thus meeting the full specs.</li>
</ul>
<p>Partial credit is available, of course, per the judgement of the grader, but above is the coarse-grain rubric.</p>
<p><strong>Please indicate in your <code>querier/README.md</code> which of the above subsets of functionality you implemented.</strong></p>
<h2>Hints and tips</h2>
<p>There are some examples and design tips in the <a href="https://github.com/CS50DartmouthFA2025/home/blob/main/knowledge/units/querier.md">unit about querier</a>, and following units.</p>
<p>Many of the <a href="../crawler/README.md">Lab4 hints</a> and
<a href="../indexer/README.md">Lab5 hints</a> are still relevant.</p>
<p>Processing a query and ranking the results are tricky.
We encourage you to start with a simplified case, test it thoroughly, then enhance.
Easier to code, to test, and to debug, and when facing a deadline it's nice to have a less-functional program that works than a full-functional program that doesn't work.
See the section on <a href="#grading">Grading</a> regarding the points allocated as you achieve higher levels of functionality.</p>
<h3>Hashtable</h3>
<p>How big should your hashtable be?
Well, you can know how many words it will store - because the index file has one word per line, and you can count the number of lines in the index file before creating an index data structure and before loading the file into the structure.
Just think about how the hash-table size (in slots) might relate to the number of words it will need to store.</p>
<h3>Parsing queries</h3>
<p>We strongly recommend that your code read the entire query (a line of input) into a single string; then verify the string contains only letters and spaces; if so, then <em>tokenize</em> the query string.</p>
<p>To tokenize, write a function that takes a string and builds an array of words (tokens), using space (<code>isspace</code>) as the delimiter; each word can be normalized (lower-cased) before being added to the array.
See a <a href="https://github.com/CS50DartmouthFA2025/home/blob/main/knowledge/units/querier-chop.md">unit</a> for inspiration (though significant adaptation is needed).</p>
<blockquote>
<p>Note: from painful experience, we specifically recommend you avoid <code>strtok</code> and related functions.</p>
</blockquote>
<p>Now that all the character-by-character parsing is behind you, and you have an array of words, you can step through the array to print a <em>clean query</em>, that is, with no extraneous spaces and all letters in lower case.</p>
<p>You can then step through the array according to the structure defined in the BNF.
Two tips:</p>
<ul>
<li>Validate the basic structure: neither the first or last word may be an operator, and two operators may not be adjacent.
If valid, proceed to next step; otherwise print a suitable error message.</li>
<li>Structure your code to follow the structure of the grammar, which has two non-terminals (<code>query</code> and <code>andsequence</code>): an inner loop over words in the <code>andsequence</code>, accumulating an answer (like a running product) as you go, and stopping when you reach <code>or</code> or the end of the array; an outer loop over a sequence of <code>andsequence</code> separated by <code>or</code>; accumulate an answer (like a running total) as you go.</li>
</ul>
<p>Read the <a href="https://github.com/CS50DartmouthFA2025/home/blob/main/knowledge/units/querier-expressions.md">unit about parsing expressions</a> for more hints about how this might work.</p>
<h3>Combining results</h3>
<p>Suppose you have one <code>counters</code> object representing the set of documents in which a given word appears, and another <code>counters</code> object representing the set of documents in which another word appears; each counter set is really a set of (docID, count) pairs.
How do you combine them?
Recall <a href="https://github.com/CS50DartmouthFA2025/home/blob/main/knowledge/units/iterators.md">unit about iterators</a>.</p>
<p>If you are processing <code>wordA AND wordB</code>, the set of documents that match <em>both</em> words is the <em>intersection</em> of the two sets, and the score for each document (per the specs) is the <em>minimum</em> of the count for each document.
So you need a way to intersect two <code>counters</code>; we recommend iterating over one set and, for each item, checking whether that document exists in the other set; update the first set according to what you find.
You can use <code>counters_iterate</code>, <code>counters_get</code>, and <code>counters_set</code> to do this, without modifying your <code>counters</code> module.</p>
<p>If you are processing <code>wordA OR wordB</code>, the set of documents that match <em>either</em> word is the <em>union</em> of the two sets, and the score for each document (per the definition above) is the <em>sum</em> of the count for each document.
So you need a way to union two <code>counters</code>; we recommend iterating over the second set and, for each item, checking whether that document exists in the first set; update the first set according to what you find.
Again, you can use <code>counters_iterate</code>, <code>counters_get</code>, and <code>counters_set</code> to do this, without modifying your <code>counters</code> module.</p>
<p>While processing an <code>andsequence</code> you can compute a 'running product', that is, a <code>counters</code> object that represents the intersection of everything seen so far in the sequence.</p>
<p>When processing a query, that is, a disjunction of <code>andsequence</code> results, you can similarly compute a 'running sum', that is, a <code>counters</code> object that represents the union of everything seen so far in the sequence.</p>
<h3>Ranking results</h3>
<p>After parsing and interpreting a query, you will likely have a <code>counters</code> object representing the score for each satisfying document.
The <code>counters</code> module does not have a 'sort' method or a way to iterate over the items in sorted order.
We suggest you use  <code>counters_iterate()</code> to identify the max-scoring item, print it out, and then <code>counters_set()</code> to set its counter value to zero; this approach is effectively a 'selection sort'.
Recall <a href="https://github.com/CS50DartmouthFA2025/home/blob/main/knowledge/units/iterators.md">unit about iterators</a>.</p>
<h3>ctype</h3>
<p>You may find the functions <code>isalpha()</code> and <code>isspace()</code> useful; read their man pages.
To use them, you need to <code>#include &lt;ctype.h&gt;</code>.</p>
<h3>Testing your querier</h3>
<p>If your indexer never quite worked, never fear.
You do not need a working indexer to write or test your querier.
Try your querier on the output of our crawler and indexer in the shared directory <code>~/cs50-dev/shared/tse/output/</code>.</p>
<p>Your querier reads queries from stdin, one per line.
You can test it interactively, but to do thorough and repeated testing you can write a collection of little files, each of which contains one or more queries to your querier, and run commands like <code>./querier ... &lt; testquery</code>.
You might write a short bash script to run the querier through several such test files.
That script might even compare the output to known-good output, for regression testing.</p>
<p>Read the <a href="https://github.com/CS50DartmouthFA2025/home/blob/main/knowledge/units/querier-testing.md">unit about fuzz testing</a>;
you are welcome to copy into your repo our <code>~/cs50-dev/shared/tse/fuzzquery.c</code>.
If it is used in your testing script, you should commit/push it to your repo.</p>
<h3>Turning off the prompt</h3>
<p>I found it useful to print a prompt for an interactive user (when stdin is a &quot;tty&quot;, aka teletype, aka keyboard), but not print a prompt when the stdin is not a keyboard (it makes output of my test runs look nicer).
I wrapped it in a little function to abstract the details:</p>
<pre><code class="language-c">#include &lt;unistd.h&gt;  // add this to your list of includes
/* The fileno() function is provided by stdio,
 * but for some reason not declared by stdio.h, so declare here.
 */
int fileno(FILE *stream);

static void
prompt(void)
{
  // print a prompt iff stdin is a tty (terminal)
  if (isatty(fileno(stdin))) {
    printf(&quot;Query? &quot;);
  }
}
</code></pre>

    </div>
</body>
</html>